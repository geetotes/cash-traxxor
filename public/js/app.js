/*
 * For simplicity's sake, I've kept the entire app in a single javascript file.
 *
 * I'll try to walk you through what's going on in the comments
 *
 */

//Once jQuery is loaded, the $ operator will be available and we call the app through an anonymous function
$(function(){

  /*
   * Backbone apps typically have three parts: a model, a collection (of models) and a view.
   *
   * The model for the expenses is pretty simple; a item name and corresponding amount.
   * Eventually, I want to put in a user ID to keep track of which users have which expenses,
   * so they can log back in to the app and see the expenses they've already put in.
   *
   * But for now, I'm keeping it simple.
   */

  window.Expense = Backbone.Model.extend({
    defaults: {
      "item": "pizza",
      "amount": "300"
    } //TODO: add a url at some point too for passing expenses back to the server, along with a user id
  });

  /*
   * The ExpenseCollection is what all the Expense (models) live in. I need to have
   * this collection in order to have the sumExpenses function, which will parse through
   * each Expense and grab its amount and add that to a running total. After all the models
   * are parsed, it returns the total which is rendered later on in a view
   */

  window.ExpenseCollection = Backbone.Collection.extend({
    model: Expense,
    sumExpenses: function(){
      var total = 0;
      this.each(function(model){
        total += parseInt(model.get('amount')); //need to be explicit here, or selse the string gets concatenated
      });
      return total;
    }
  });

  /*
   * Here we init a new ExpenseCollection
   */

  window.Expenses = new ExpenseCollection;

  /*
   * This view renders the individual expenses, taking data from the model and putting
   * it into an <li> html tag. These rendered views are appended to a list of expenses.
   *
   * You can see the underscore template I'm using in the HTML itself near the bottom of
   * page's source.
   */

  window.ExpenseView = Backbone.View.extend({
    tagName: "li", //let's make this an li
    template: _.template($('#spend-template').html()),
    render: function(){
      /*
       * One of the things I really like about Backbone is how nicely it plays with the
       * this keyword. Below, this.template refers to the _.template underscore function I
       * called above, which prepped my template.
       *
       * this.el is the same thing as this.tagName, which is also defined above.
       *
       * this.model is defined when I call a new ExpenseView, which happens later in the code.
       * 
       * When the model is converted to JSON, the _.template function will take the JSON and 
       * replace the <%= item => and <%= amount => placeholders in the template with the corresponding
       * JSON values
       */
      $(this.el).html(this.template(this.model.toJSON()));
      return this;
    }
  });

  /*
   * This view, the GraphView, doesn't have a model or collection attached to it.
   * It's basically a wrapper for accessing the nvd3 library, which is used to render
   * the graph. In this view, there are a bunch of non-Backbone specific functions used
   * to generate the datapoints for the graph
   * */

  window.GraphView = Backbone.View.extend({
    el: $("#viz"),

    /* 
     * 2 simple helper functions for grabbing totals, which are used
     * by the dataGenerate function.
     */
    totalIncome: function(){
      return $('#income').val() * $('#frequency').val();
    },
    totalExpenses: function(){
      return $('#sum-expenses').val();
    },

    /*
     * chartValues takes the arrays generated by generateData and puts them into another array that
     * has nvd3.js specific keys for doing the colors and labels
     * */

    chartValues: function(){

      /*
       * I played around alot with getting the income graph to look right.
       * Dividing it into 6ths created the most visually appealing graph.
       */

      var avgAmt = Math.floor(this.totalIncome()/6);

      return [{ values: this.generateData(true, avgAmt), key: "cash", color: "#2ca02c"},
             { values: this.generateData(false, $('#sum-expenses').val()), area: true, key: "spending", color:"lightsalmon"}];
    },

    /*
     * While it looks complicated, generateData basically takes an amount and create a series of
     * x and y datapoints to feed to the graph. The end result is something that looks like
     * [{x:1, y:1}, {x:4, y:2} etc etc] which are then fed into nvd3 to map out the points on the graph
     *
     * There is also some date handling code so the timeline on the graph reflects the current month and increments
     * the days (the x value) correctly.
     *
     */

    generateData: function(income, amount){
      var now = new Date(),
        x,
        y,
        generatedData = [],
        frequency = 6,
        currMonth = now.getMonth() + 1, //months 0 indexed
        days = new Date(now.getFullYear(), currMonth, 0).getDate(),
        daysIncrement = Math.floor(days/frequency);

      for(var i = 1; i <= frequency; i++)
      {
        /*
         * Check to see if this is an expense or income
         *
         * If it is an expense, we want to do a flat line, so the y value should always be the same.
         * If it is income, we want the line to climb up, so we change the y value in the loop.
         */
        if(income)
          generatedData.push({x: new Date(now.getFullYear(), now.getMonth(), i * daysIncrement).getTime(), y: (i * amount)});
        else
          generatedData.push({x: new Date(now.getFullYear(), now.getMonth(), i * daysIncrement).getTime(), y: (amount)});
      }
      //based on this.amount, this.income, and frequency, this will generate the x/y data
      return generatedData;


    },

    /*
     * This function is mostly formatting code for the chart.
     */

    chart: function(){
      var chart = nv.models.lineChart(),
      data = this.chartValues();

      chart.x(function(d,i){return i});
      chart.xAxis
        .axisLabel('Time')
        .tickFormat(function(d){
          var dx = data[0].values[d] && data[0].values[d].x || 0;
          return d3.time.format('%x')(new Date(dx))
        });
      chart.yAxis
        .axisLabel('Money')
        .tickFormat(d3.format('.02f'));
      d3.select("#viz svg")
        .datum(data)
        .transition().duration(500)
        .call(chart);

      nv.utils.windowResize(function() { d3.select("#viz svg").call(chart)});

      return chart;
    },

    /*
     * This may be an example of bad application design, since the setText function 
     * modifies text that's outside of its enclosing <div> (the "You saved X amount"
     * text). However, it was easiest to do it here, since this view has access to 
     * the total income and total expenses that the user inputs.
     */

    setText: function(){
      if((this.totalIncome() - this.totalExpenses()) > 0) 
        $('#savings').text(this.totalIncome() - this.totalExpenses()).css("color", "black");
      else
        $('#savings').text(this.totalIncome() - this.totalExpenses()).css("color", "red");
    },

    /*
     * The render function re-creates the graph and associated data, then changes the
     * text based on the total income and total expenses.
     */

    render: function(){
      nv.addGraph(this.chart());
      this.setText();
    }
  });

  /*
   * This is our main view, from which everything else gets called.
   */

  window.AppView = Backbone.View.extend({
  el: $("#app"),
  collection: Expenses, // <---- the expense collection from above

  events: {
    "change .trigger": "render",
    "click #add-expense" : "newExpense",
    "focus input": "clearInput"
    //TODO: add listener for enter key, or put input boxes in a proper form
  },

  /*
   * This is a very important part of the code.
   *
   * I've added event listeners on the collection to handle
   * the rendering of new models to the collection. Without
   * this event binding, expenses wouldn't render when you add them.
   */

  initialize: function(){
    //wire up collections
    this.collection.bind('add', this.addOne, this);
    this.collection.bind('reset', this.addAll, this);

    //clear out total expenses that's populated by browser remembering things
    $('#sum-expenses').val('');

    this.render();
  },

  /*
   * clearInput is mostly a UI prefrence of mine, I like to have the 
   * default text of an input box cleared out when I click on it.
   *
   * There is also a check in here to not clear things out automatically
   * if the text on a input box has already been changed by a user.
   */

  clearInput: function(e){
    var targetEl = $(e.currentTarget);
    if(targetEl.val() == e.currentTarget.defaultValue)
      targetEl.val('');
  },

  /*
   * This is the function that adds a new expense to the expense collection.
   * 
   * First, we check to see if the expense is a number. If not, we will get a
   * Not a Number error. Then, if it is, we create a new expense and pull values
   * from the input boxes to fill in the model.
   *
   * Then we add the expense to the collection.
   */

  newExpense: function(e){
    e.preventDefault();
    //check to see if the amount is legit
    if($.isNumeric($('#expense-amount').val())) {
      var expense = new Expense;
      expense.set({item: $('#expense-name').val(), amount: $('#expense-amount').val()});
      this.collection.add(expense);
      //clear out for new stuff
      $('#expense-name').val('');
      $('#expense-amount').val('');
    } else {
      $('#expense-amount').addClass('error');
    }

  },

  /*
   * The addOne function below will be called thanks to the event binding in the
   * initialize part of this view.
   *
   * The expense model is passed in as a parameter, the expense view (the <li>) is
   * rendered, then some fancy jQuery animation slides it into place.
   *
   * After the new expense is on the screen, the sumExpense function is called on the 
   * expense collection to update the Total section of the UI.
   *
   * After the Total is updated, a change is manually triggered and the graph is re-rendered
   */

  addOne: function(expense){
    $('#expense-amount').removeClass('error'); //if there is an error class, let's remove it
    var view = new ExpenseView({model: expense});
    var render = view.render().el;
    this.$('#spendlist').append(render);
    $(render).slideDown("slow");
    this.$('#sum-expenses').val(this.collection.sumExpenses());
    this.$('#sum-expenses').trigger('change'); //need to manually trigger the change here
  },

  /*
   * The addAll function just iterates over the expenses collection, rendering all of the expenses
   */

  allAll: function (){
    this.$('#spendlist').empty();
    this.collection.each(this.addOne);
  },

  /*
   * The render function of this view is a bit mis-named, but it just checks
   * to make sure the income that the user has inputted is a number, then renders
   * (or re-renders) the graph
   */

  render: function(){
    //check to make sure income is legit
    if($.isNumeric($('#income').val())) {
      $('#income').removeClass('error');
      var graph = new GraphView;
      graph.render();
    }else{
      $('#income').addClass('error');
    }

  }
  });

  /*
   * Let's make a new AppView to kick everything off
   */
  window.app = new AppView;

});
